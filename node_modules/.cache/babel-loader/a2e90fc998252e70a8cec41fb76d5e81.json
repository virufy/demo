{"ast":null,"code":"import _objectSpread from \"/home/amil/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";\nimport _regeneratorRuntime from \"/home/amil/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\nimport _asyncToGenerator from \"/home/amil/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport _createForOfIteratorHelper from \"/home/amil/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper\";\nimport _toConsumableArray from \"/home/amil/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/amil/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/amil/virufy-demo.github.io/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\n\nfunction toRequest(input) {\n  return typeof input === 'string' ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * [handle()]{@link module:workbox-strategies.Strategy~handle} or\n * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof module:workbox-strategies\n */\n\n\nvar StrategyHandler = /*#__PURE__*/function () {\n  /**\n   * Creates a new instance associated with the passed strategy and event\n   * that's handling the request.\n   *\n   * The constructor also initializes the state that will be passed to each of\n   * the plugins handling this request.\n   *\n   * @param {module:workbox-strategies.Strategy} strategy\n   * @param {Object} options\n   * @param {Request|string} options.request A request to run this strategy for.\n   * @param {ExtendableEvent} options.event The event associated with the\n   *     request.\n   * @param {URL} [options.url]\n   * @param {*} [options.params]\n   *     [match callback]{@link module:workbox-routing~matchCallback},\n   *     (if applicable).\n   */\n  function StrategyHandler(strategy, options) {\n    _classCallCheck(this, StrategyHandler);\n\n    this._cacheKeys = {};\n    /**\n     * The request the strategy is performing (passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * @name request\n     * @instance\n     * @type {Request}\n     * @memberof module:workbox-strategies.StrategyHandler\n     */\n\n    /**\n     * The event associated with this request.\n     * @name event\n     * @instance\n     * @type {ExtendableEvent}\n     * @memberof module:workbox-strategies.StrategyHandler\n     */\n\n    /**\n     * A `URL` instance of `request.url` (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `url` param will be present if the strategy was invoked\n     * from a workbox `Route` object.\n     * @name url\n     * @instance\n     * @type {URL|undefined}\n     * @memberof module:workbox-strategies.StrategyHandler\n     */\n\n    /**\n     * A `param` value (if passed to the strategy's\n     * `handle()` or `handleAll()` method).\n     * Note: the `param` param will be present if the strategy was invoked\n     * from a workbox `Route` object and the\n     * [match callback]{@link module:workbox-routing~matchCallback} returned\n     * a truthy value (it will be that value).\n     * @name params\n     * @instance\n     * @type {*|undefined}\n     * @memberof module:workbox-strategies.StrategyHandler\n     */\n\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(options.event, ExtendableEvent, {\n        moduleName: 'workbox-strategies',\n        className: 'StrategyHandler',\n        funcName: 'constructor',\n        paramName: 'options.event'\n      });\n    }\n\n    Object.assign(this, options);\n    this.event = options.event;\n    this._strategy = strategy;\n    this._handlerDeferred = new Deferred();\n    this._extendLifetimePromises = []; // Copy the plugins list (since it's mutable on the strategy),\n    // so any mutations don't affect this handler instance.\n\n    this._plugins = _toConsumableArray(strategy.plugins);\n    this._pluginStateMap = new Map();\n\n    var _iterator = _createForOfIteratorHelper(this._plugins),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var plugin = _step.value;\n\n        this._pluginStateMap.set(plugin, {});\n      }\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    this.event.waitUntil(this._handlerDeferred.promise);\n  }\n  /**\n   * Fetches a given request (and invokes any applicable plugin callback\n   * methods) using the `fetchOptions` and `plugins` defined on the strategy\n   * object.\n   *\n   * The following plugin lifecycle methods are invoked when using this method:\n   * - `requestWillFetch()`\n   * - `fetchDidSucceed()`\n   * - `fetchDidFail()`\n   *\n   * @param {Request|string} input The URL or request to fetch.\n   * @return {Promise<Response>}\n   */\n\n\n  _createClass(StrategyHandler, [{\n    key: \"fetch\",\n    value: function (_fetch) {\n      function fetch(_x) {\n        return _fetch.apply(this, arguments);\n      }\n\n      fetch.toString = function () {\n        return _fetch.toString();\n      };\n\n      return fetch;\n    }(function (input) {\n      var _this = this;\n\n      return this.waitUntil(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var event, request, possiblePreloadResponse, originalRequest, _iterator2, _step2, cb, pluginFilteredRequest, fetchResponse, _iterator3, _step3, callback;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                event = _this.event;\n                request = toRequest(input);\n\n                if (!(request.mode === 'navigate' && event instanceof FetchEvent && event.preloadResponse)) {\n                  _context.next = 9;\n                  break;\n                }\n\n                _context.next = 5;\n                return event.preloadResponse;\n\n              case 5:\n                possiblePreloadResponse = _context.sent;\n\n                if (!possiblePreloadResponse) {\n                  _context.next = 9;\n                  break;\n                }\n\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.log(\"Using a preloaded navigation response for \" + \"'\".concat(getFriendlyURL(request.url), \"'\"));\n                }\n\n                return _context.abrupt(\"return\", possiblePreloadResponse);\n\n              case 9:\n                // If there is a fetchDidFail plugin, we need to save a clone of the\n                // original request before it's either modified by a requestWillFetch\n                // plugin or before the original request's body is consumed via fetch().\n                originalRequest = _this.hasCallback('fetchDidFail') ? request.clone() : null;\n                _context.prev = 10;\n                _iterator2 = _createForOfIteratorHelper(_this.iterateCallbacks('requestWillFetch'));\n                _context.prev = 12;\n\n                _iterator2.s();\n\n              case 14:\n                if ((_step2 = _iterator2.n()).done) {\n                  _context.next = 21;\n                  break;\n                }\n\n                cb = _step2.value;\n                _context.next = 18;\n                return cb({\n                  request: request.clone(),\n                  event: event\n                });\n\n              case 18:\n                request = _context.sent;\n\n              case 19:\n                _context.next = 14;\n                break;\n\n              case 21:\n                _context.next = 26;\n                break;\n\n              case 23:\n                _context.prev = 23;\n                _context.t0 = _context[\"catch\"](12);\n\n                _iterator2.e(_context.t0);\n\n              case 26:\n                _context.prev = 26;\n\n                _iterator2.f();\n\n                return _context.finish(26);\n\n              case 29:\n                _context.next = 34;\n                break;\n\n              case 31:\n                _context.prev = 31;\n                _context.t1 = _context[\"catch\"](10);\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                  thrownError: _context.t1\n                });\n\n              case 34:\n                // The request can be altered by plugins with `requestWillFetch` making\n                // the original request (most likely from a `fetch` event) different\n                // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n                pluginFilteredRequest = request.clone();\n                _context.prev = 35;\n                _context.next = 38;\n                return fetch(request, request.mode === 'navigate' ? undefined : _this._strategy.fetchOptions);\n\n              case 38:\n                fetchResponse = _context.sent;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.debug(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' returned a response with \") + \"status '\".concat(fetchResponse.status, \"'.\"));\n                }\n\n                _iterator3 = _createForOfIteratorHelper(_this.iterateCallbacks('fetchDidSucceed'));\n                _context.prev = 41;\n\n                _iterator3.s();\n\n              case 43:\n                if ((_step3 = _iterator3.n()).done) {\n                  _context.next = 50;\n                  break;\n                }\n\n                callback = _step3.value;\n                _context.next = 47;\n                return callback({\n                  event: event,\n                  request: pluginFilteredRequest,\n                  response: fetchResponse\n                });\n\n              case 47:\n                fetchResponse = _context.sent;\n\n              case 48:\n                _context.next = 43;\n                break;\n\n              case 50:\n                _context.next = 55;\n                break;\n\n              case 52:\n                _context.prev = 52;\n                _context.t2 = _context[\"catch\"](41);\n\n                _iterator3.e(_context.t2);\n\n              case 55:\n                _context.prev = 55;\n\n                _iterator3.f();\n\n                return _context.finish(55);\n\n              case 58:\n                return _context.abrupt(\"return\", fetchResponse);\n\n              case 61:\n                _context.prev = 61;\n                _context.t3 = _context[\"catch\"](35);\n\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.error(\"Network request for \" + \"'\".concat(getFriendlyURL(request.url), \"' threw an error.\"), _context.t3);\n                } // `originalRequest` will only exist if a `fetchDidFail` callback\n                // is being used (see above).\n\n\n                if (!originalRequest) {\n                  _context.next = 67;\n                  break;\n                }\n\n                _context.next = 67;\n                return _this.runCallbacks('fetchDidFail', {\n                  error: _context.t3,\n                  event: event,\n                  originalRequest: originalRequest.clone(),\n                  request: pluginFilteredRequest.clone()\n                });\n\n              case 67:\n                throw _context.t3;\n\n              case 68:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, null, [[10, 31], [12, 23, 26, 29], [35, 61], [41, 52, 55, 58]]);\n      }))());\n    })\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n\n  }, {\n    key: \"fetchAndCachePut\",\n    value: function () {\n      var _fetchAndCachePut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(input) {\n        var response, responseClone;\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                _context2.next = 2;\n                return this.fetch(input);\n\n              case 2:\n                response = _context2.sent;\n                responseClone = response.clone();\n                this.waitUntil(this.cachePut(input, responseClone));\n                return _context2.abrupt(\"return\", response);\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function fetchAndCachePut(_x2) {\n        return _fetchAndCachePut.apply(this, arguments);\n      }\n\n      return fetchAndCachePut;\n    }()\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n\n  }, {\n    key: \"cacheMatch\",\n    value: function cacheMatch(key) {\n      var _this2 = this;\n\n      return this.waitUntil(_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var request, cachedResponse, _this2$_strategy, cacheName, matchOptions, effectiveRequest, multiMatchOptions, _iterator4, _step4, callback;\n\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                request = toRequest(key);\n                _this2$_strategy = _this2._strategy, cacheName = _this2$_strategy.cacheName, matchOptions = _this2$_strategy.matchOptions;\n                _context3.next = 4;\n                return _this2.getCacheKey(request, 'read');\n\n              case 4:\n                effectiveRequest = _context3.sent;\n                multiMatchOptions = _objectSpread(_objectSpread({}, matchOptions), {\n                  cacheName: cacheName\n                });\n                _context3.next = 8;\n                return caches.match(effectiveRequest, multiMatchOptions);\n\n              case 8:\n                cachedResponse = _context3.sent;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  if (cachedResponse) {\n                    logger.debug(\"Found a cached response in '\".concat(cacheName, \"'.\"));\n                  } else {\n                    logger.debug(\"No cached response found in '\".concat(cacheName, \"'.\"));\n                  }\n                }\n\n                _iterator4 = _createForOfIteratorHelper(_this2.iterateCallbacks('cachedResponseWillBeUsed'));\n                _context3.prev = 11;\n\n                _iterator4.s();\n\n              case 13:\n                if ((_step4 = _iterator4.n()).done) {\n                  _context3.next = 23;\n                  break;\n                }\n\n                callback = _step4.value;\n                _context3.next = 17;\n                return callback({\n                  cacheName: cacheName,\n                  matchOptions: matchOptions,\n                  cachedResponse: cachedResponse,\n                  request: effectiveRequest,\n                  event: _this2.event\n                });\n\n              case 17:\n                _context3.t0 = _context3.sent;\n\n                if (_context3.t0) {\n                  _context3.next = 20;\n                  break;\n                }\n\n                _context3.t0 = undefined;\n\n              case 20:\n                cachedResponse = _context3.t0;\n\n              case 21:\n                _context3.next = 13;\n                break;\n\n              case 23:\n                _context3.next = 28;\n                break;\n\n              case 25:\n                _context3.prev = 25;\n                _context3.t1 = _context3[\"catch\"](11);\n\n                _iterator4.e(_context3.t1);\n\n              case 28:\n                _context3.prev = 28;\n\n                _iterator4.f();\n\n                return _context3.finish(28);\n\n              case 31:\n                return _context3.abrupt(\"return\", cachedResponse);\n\n              case 32:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, null, [[11, 25, 28, 31]]);\n      }))());\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Promise<void>} response The response to cache.\n     */\n\n  }, {\n    key: \"cachePut\",\n    value: function () {\n      var _cachePut = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4(key, response) {\n        var request, effectiveRequest, responseToCache, _this$_strategy, cacheName, matchOptions, cache, hasCacheUpdateCallback, oldResponse, _iterator5, _step5, callback;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                request = toRequest(key); // Run in the next task to avoid blocking other cache reads.\n                // https://github.com/w3c/ServiceWorker/issues/1397\n\n                _context4.next = 3;\n                return timeout(0);\n\n              case 3:\n                _context4.next = 5;\n                return this.getCacheKey(request, 'write');\n\n              case 5:\n                effectiveRequest = _context4.sent;\n\n                if (!(process.env.NODE_ENV !== 'production')) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                if (!(effectiveRequest.method && effectiveRequest.method !== 'GET')) {\n                  _context4.next = 9;\n                  break;\n                }\n\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                  url: getFriendlyURL(effectiveRequest.url),\n                  method: effectiveRequest.method\n                });\n\n              case 9:\n                if (response) {\n                  _context4.next = 12;\n                  break;\n                }\n\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.error(\"Cannot cache non-existent response for \" + \"'\".concat(getFriendlyURL(effectiveRequest.url), \"'.\"));\n                }\n\n                throw new WorkboxError('cache-put-with-no-response', {\n                  url: getFriendlyURL(effectiveRequest.url)\n                });\n\n              case 12:\n                _context4.next = 14;\n                return this._ensureResponseSafeToCache(response);\n\n              case 14:\n                responseToCache = _context4.sent;\n\n                if (responseToCache) {\n                  _context4.next = 18;\n                  break;\n                }\n\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.debug(\"Response '\".concat(getFriendlyURL(effectiveRequest.url), \"' \") + \"will not be cached.\", responseToCache);\n                }\n\n                return _context4.abrupt(\"return\");\n\n              case 18:\n                _this$_strategy = this._strategy, cacheName = _this$_strategy.cacheName, matchOptions = _this$_strategy.matchOptions;\n                _context4.next = 21;\n                return self.caches.open(cacheName);\n\n              case 21:\n                cache = _context4.sent;\n                hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n\n                if (!hasCacheUpdateCallback) {\n                  _context4.next = 29;\n                  break;\n                }\n\n                _context4.next = 26;\n                return cacheMatchIgnoreParams( // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n                // feature. Consider into ways to only add this behavior if using\n                // precaching.\n                cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions);\n\n              case 26:\n                _context4.t0 = _context4.sent;\n                _context4.next = 30;\n                break;\n\n              case 29:\n                _context4.t0 = null;\n\n              case 30:\n                oldResponse = _context4.t0;\n\n                if (process.env.NODE_ENV !== 'production') {\n                  logger.debug(\"Updating the '\".concat(cacheName, \"' cache with a new Response \") + \"for \".concat(getFriendlyURL(effectiveRequest.url), \".\"));\n                }\n\n                _context4.prev = 32;\n                _context4.next = 35;\n                return cache.put(effectiveRequest, hasCacheUpdateCallback ? responseToCache.clone() : responseToCache);\n\n              case 35:\n                _context4.next = 43;\n                break;\n\n              case 37:\n                _context4.prev = 37;\n                _context4.t1 = _context4[\"catch\"](32);\n\n                if (!(_context4.t1.name === 'QuotaExceededError')) {\n                  _context4.next = 42;\n                  break;\n                }\n\n                _context4.next = 42;\n                return executeQuotaErrorCallbacks();\n\n              case 42:\n                throw _context4.t1;\n\n              case 43:\n                _iterator5 = _createForOfIteratorHelper(this.iterateCallbacks('cacheDidUpdate'));\n                _context4.prev = 44;\n\n                _iterator5.s();\n\n              case 46:\n                if ((_step5 = _iterator5.n()).done) {\n                  _context4.next = 52;\n                  break;\n                }\n\n                callback = _step5.value;\n                _context4.next = 50;\n                return callback({\n                  cacheName: cacheName,\n                  oldResponse: oldResponse,\n                  newResponse: responseToCache.clone(),\n                  request: effectiveRequest,\n                  event: this.event\n                });\n\n              case 50:\n                _context4.next = 46;\n                break;\n\n              case 52:\n                _context4.next = 57;\n                break;\n\n              case 54:\n                _context4.prev = 54;\n                _context4.t2 = _context4[\"catch\"](44);\n\n                _iterator5.e(_context4.t2);\n\n              case 57:\n                _context4.prev = 57;\n\n                _iterator5.f();\n\n                return _context4.finish(57);\n\n              case 60:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[32, 37], [44, 54, 57, 60]]);\n      }));\n\n      function cachePut(_x3, _x4) {\n        return _cachePut.apply(this, arguments);\n      }\n\n      return cachePut;\n    }()\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n\n  }, {\n    key: \"getCacheKey\",\n    value: function () {\n      var _getCacheKey = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(request, mode) {\n        var effectiveRequest, _iterator6, _step6, callback;\n\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this._cacheKeys[mode]) {\n                  _context5.next = 23;\n                  break;\n                }\n\n                effectiveRequest = request;\n                _iterator6 = _createForOfIteratorHelper(this.iterateCallbacks('cacheKeyWillBeUsed'));\n                _context5.prev = 3;\n\n                _iterator6.s();\n\n              case 5:\n                if ((_step6 = _iterator6.n()).done) {\n                  _context5.next = 14;\n                  break;\n                }\n\n                callback = _step6.value;\n                _context5.t0 = toRequest;\n                _context5.next = 10;\n                return callback({\n                  mode: mode,\n                  request: effectiveRequest,\n                  event: this.event,\n                  params: this.params\n                });\n\n              case 10:\n                _context5.t1 = _context5.sent;\n                effectiveRequest = (0, _context5.t0)(_context5.t1);\n\n              case 12:\n                _context5.next = 5;\n                break;\n\n              case 14:\n                _context5.next = 19;\n                break;\n\n              case 16:\n                _context5.prev = 16;\n                _context5.t2 = _context5[\"catch\"](3);\n\n                _iterator6.e(_context5.t2);\n\n              case 19:\n                _context5.prev = 19;\n\n                _iterator6.f();\n\n                return _context5.finish(19);\n\n              case 22:\n                this._cacheKeys[mode] = effectiveRequest;\n\n              case 23:\n                return _context5.abrupt(\"return\", this._cacheKeys[mode]);\n\n              case 24:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this, [[3, 16, 19, 22]]);\n      }));\n\n      function getCacheKey(_x5, _x6) {\n        return _getCacheKey.apply(this, arguments);\n      }\n\n      return getCacheKey;\n    }()\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n\n  }, {\n    key: \"hasCallback\",\n    value: function hasCallback(name) {\n      var _iterator7 = _createForOfIteratorHelper(this._strategy.plugins),\n          _step7;\n\n      try {\n        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n          var plugin = _step7.value;\n\n          if (name in plugin) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator7.e(err);\n      } finally {\n        _iterator7.f();\n      }\n\n      return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n\n  }, {\n    key: \"runCallbacks\",\n    value: function () {\n      var _runCallbacks = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(name, param) {\n        var _iterator8, _step8, callback;\n\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                _iterator8 = _createForOfIteratorHelper(this.iterateCallbacks(name));\n                _context6.prev = 1;\n\n                _iterator8.s();\n\n              case 3:\n                if ((_step8 = _iterator8.n()).done) {\n                  _context6.next = 9;\n                  break;\n                }\n\n                callback = _step8.value;\n                _context6.next = 7;\n                return callback(param);\n\n              case 7:\n                _context6.next = 3;\n                break;\n\n              case 9:\n                _context6.next = 14;\n                break;\n\n              case 11:\n                _context6.prev = 11;\n                _context6.t0 = _context6[\"catch\"](1);\n\n                _iterator8.e(_context6.t0);\n\n              case 14:\n                _context6.prev = 14;\n\n                _iterator8.f();\n\n                return _context6.finish(14);\n\n              case 17:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this, [[1, 11, 14, 17]]);\n      }));\n\n      function runCallbacks(_x7, _x8) {\n        return _runCallbacks.apply(this, arguments);\n      }\n\n      return runCallbacks;\n    }()\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n\n  }, {\n    key: \"iterateCallbacks\",\n    value: /*#__PURE__*/_regeneratorRuntime.mark(function iterateCallbacks(name) {\n      var _this3 = this;\n\n      var _iterator9, _step9, _loop;\n\n      return _regeneratorRuntime.wrap(function iterateCallbacks$(_context8) {\n        while (1) {\n          switch (_context8.prev = _context8.next) {\n            case 0:\n              _iterator9 = _createForOfIteratorHelper(this._strategy.plugins);\n              _context8.prev = 1;\n              _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                var plugin, state, statefulCallback;\n                return _regeneratorRuntime.wrap(function _loop$(_context7) {\n                  while (1) {\n                    switch (_context7.prev = _context7.next) {\n                      case 0:\n                        plugin = _step9.value;\n\n                        if (!(typeof plugin[name] === 'function')) {\n                          _context7.next = 6;\n                          break;\n                        }\n\n                        state = _this3._pluginStateMap.get(plugin);\n\n                        statefulCallback = function statefulCallback(param) {\n                          var statefulParam = _objectSpread(_objectSpread({}, param), {}, {\n                            state: state\n                          }); // TODO(philipwalton): not sure why `any` is needed. It seems like\n                          // this should work with `as WorkboxPluginCallbackParam[C]`.\n\n\n                          return plugin[name](statefulParam);\n                        };\n\n                        _context7.next = 6;\n                        return statefulCallback;\n\n                      case 6:\n                      case \"end\":\n                        return _context7.stop();\n                    }\n                  }\n                }, _loop);\n              });\n\n              _iterator9.s();\n\n            case 4:\n              if ((_step9 = _iterator9.n()).done) {\n                _context8.next = 8;\n                break;\n              }\n\n              return _context8.delegateYield(_loop(), \"t0\", 6);\n\n            case 6:\n              _context8.next = 4;\n              break;\n\n            case 8:\n              _context8.next = 13;\n              break;\n\n            case 10:\n              _context8.prev = 10;\n              _context8.t1 = _context8[\"catch\"](1);\n\n              _iterator9.e(_context8.t1);\n\n            case 13:\n              _context8.prev = 13;\n\n              _iterator9.f();\n\n              return _context8.finish(13);\n\n            case 16:\n            case \"end\":\n              return _context8.stop();\n          }\n        }\n      }, iterateCallbacks, this, [[1, 10, 13, 16]]);\n    })\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n\n  }, {\n    key: \"waitUntil\",\n    value: function waitUntil(promise) {\n      this._extendLifetimePromises.push(promise);\n\n      return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n\n  }, {\n    key: \"doneWaiting\",\n    value: function () {\n      var _doneWaiting = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee7() {\n        var promise;\n        return _regeneratorRuntime.wrap(function _callee7$(_context9) {\n          while (1) {\n            switch (_context9.prev = _context9.next) {\n              case 0:\n                if (!(promise = this._extendLifetimePromises.shift())) {\n                  _context9.next = 5;\n                  break;\n                }\n\n                _context9.next = 3;\n                return promise;\n\n              case 3:\n                _context9.next = 0;\n                break;\n\n              case 5:\n              case \"end\":\n                return _context9.stop();\n            }\n          }\n        }, _callee7, this);\n      }));\n\n      function doneWaiting() {\n        return _doneWaiting.apply(this, arguments);\n      }\n\n      return doneWaiting;\n    }()\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this._handlerDeferred.resolve();\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_ensureResponseSafeToCache\",\n    value: function () {\n      var _ensureResponseSafeToCache2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee8(response) {\n        var responseToCache, pluginsUsed, _iterator10, _step10, callback;\n\n        return _regeneratorRuntime.wrap(function _callee8$(_context10) {\n          while (1) {\n            switch (_context10.prev = _context10.next) {\n              case 0:\n                responseToCache = response;\n                pluginsUsed = false;\n                _iterator10 = _createForOfIteratorHelper(this.iterateCallbacks('cacheWillUpdate'));\n                _context10.prev = 3;\n\n                _iterator10.s();\n\n              case 5:\n                if ((_step10 = _iterator10.n()).done) {\n                  _context10.next = 18;\n                  break;\n                }\n\n                callback = _step10.value;\n                _context10.next = 9;\n                return callback({\n                  request: this.request,\n                  response: responseToCache,\n                  event: this.event\n                });\n\n              case 9:\n                _context10.t0 = _context10.sent;\n\n                if (_context10.t0) {\n                  _context10.next = 12;\n                  break;\n                }\n\n                _context10.t0 = undefined;\n\n              case 12:\n                responseToCache = _context10.t0;\n                pluginsUsed = true;\n\n                if (responseToCache) {\n                  _context10.next = 16;\n                  break;\n                }\n\n                return _context10.abrupt(\"break\", 18);\n\n              case 16:\n                _context10.next = 5;\n                break;\n\n              case 18:\n                _context10.next = 23;\n                break;\n\n              case 20:\n                _context10.prev = 20;\n                _context10.t1 = _context10[\"catch\"](3);\n\n                _iterator10.e(_context10.t1);\n\n              case 23:\n                _context10.prev = 23;\n\n                _iterator10.f();\n\n                return _context10.finish(23);\n\n              case 26:\n                if (!pluginsUsed) {\n                  if (responseToCache && responseToCache.status !== 200) {\n                    responseToCache = undefined;\n                  }\n\n                  if (process.env.NODE_ENV !== 'production') {\n                    if (responseToCache) {\n                      if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                          logger.warn(\"The response for '\".concat(this.request.url, \"' \") + \"is an opaque response. The caching strategy that you're \" + \"using will not cache opaque responses by default.\");\n                        } else {\n                          logger.debug(\"The response for '\".concat(this.request.url, \"' \") + \"returned a status code of '\".concat(response.status, \"' and won't \") + \"be cached as a result.\");\n                        }\n                      }\n                    }\n                  }\n                }\n\n                return _context10.abrupt(\"return\", responseToCache);\n\n              case 28:\n              case \"end\":\n                return _context10.stop();\n            }\n          }\n        }, _callee8, this, [[3, 20, 23, 26]]);\n      }));\n\n      function _ensureResponseSafeToCache(_x9) {\n        return _ensureResponseSafeToCache2.apply(this, arguments);\n      }\n\n      return _ensureResponseSafeToCache;\n    }()\n  }]);\n\n  return StrategyHandler;\n}();\n\nexport { StrategyHandler };","map":{"version":3,"sources":["/home/amil/virufy-demo.github.io/node_modules/workbox-strategies/StrategyHandler.js"],"names":["assert","cacheMatchIgnoreParams","Deferred","executeQuotaErrorCallbacks","getFriendlyURL","logger","timeout","WorkboxError","toRequest","input","Request","StrategyHandler","strategy","options","_cacheKeys","process","env","NODE_ENV","isInstance","event","ExtendableEvent","moduleName","className","funcName","paramName","Object","assign","_strategy","_handlerDeferred","_extendLifetimePromises","_plugins","plugins","_pluginStateMap","Map","plugin","set","waitUntil","promise","request","mode","FetchEvent","preloadResponse","possiblePreloadResponse","log","url","originalRequest","hasCallback","clone","iterateCallbacks","cb","thrownError","pluginFilteredRequest","fetch","undefined","fetchOptions","fetchResponse","debug","status","callback","response","error","runCallbacks","responseClone","cachePut","key","cacheName","matchOptions","getCacheKey","effectiveRequest","multiMatchOptions","caches","match","cachedResponse","method","_ensureResponseSafeToCache","responseToCache","self","open","cache","hasCacheUpdateCallback","oldResponse","put","name","newResponse","params","param","state","get","statefulCallback","statefulParam","push","shift","resolve","pluginsUsed","warn"],"mappings":"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","sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { assert } from 'workbox-core/_private/assert.js';\nimport { cacheMatchIgnoreParams } from 'workbox-core/_private/cacheMatchIgnoreParams.js';\nimport { Deferred } from 'workbox-core/_private/Deferred.js';\nimport { executeQuotaErrorCallbacks } from 'workbox-core/_private/executeQuotaErrorCallbacks.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { timeout } from 'workbox-core/_private/timeout.js';\nimport { WorkboxError } from 'workbox-core/_private/WorkboxError.js';\nimport './_version.js';\nfunction toRequest(input) {\n    return (typeof input === 'string') ? new Request(input) : input;\n}\n/**\n * A class created every time a Strategy instance instance calls\n * [handle()]{@link module:workbox-strategies.Strategy~handle} or\n * [handleAll()]{@link module:workbox-strategies.Strategy~handleAll} that wraps all fetch and\n * cache actions around plugin callbacks and keeps track of when the strategy\n * is \"done\" (i.e. all added `event.waitUntil()` promises have resolved).\n *\n * @memberof module:workbox-strategies\n */\nclass StrategyHandler {\n    /**\n     * Creates a new instance associated with the passed strategy and event\n     * that's handling the request.\n     *\n     * The constructor also initializes the state that will be passed to each of\n     * the plugins handling this request.\n     *\n     * @param {module:workbox-strategies.Strategy} strategy\n     * @param {Object} options\n     * @param {Request|string} options.request A request to run this strategy for.\n     * @param {ExtendableEvent} options.event The event associated with the\n     *     request.\n     * @param {URL} [options.url]\n     * @param {*} [options.params]\n     *     [match callback]{@link module:workbox-routing~matchCallback},\n     *     (if applicable).\n     */\n    constructor(strategy, options) {\n        this._cacheKeys = {};\n        /**\n         * The request the strategy is performing (passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * @name request\n         * @instance\n         * @type {Request}\n         * @memberof module:workbox-strategies.StrategyHandler\n         */\n        /**\n         * The event associated with this request.\n         * @name event\n         * @instance\n         * @type {ExtendableEvent}\n         * @memberof module:workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `URL` instance of `request.url` (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `url` param will be present if the strategy was invoked\n         * from a workbox `Route` object.\n         * @name url\n         * @instance\n         * @type {URL|undefined}\n         * @memberof module:workbox-strategies.StrategyHandler\n         */\n        /**\n         * A `param` value (if passed to the strategy's\n         * `handle()` or `handleAll()` method).\n         * Note: the `param` param will be present if the strategy was invoked\n         * from a workbox `Route` object and the\n         * [match callback]{@link module:workbox-routing~matchCallback} returned\n         * a truthy value (it will be that value).\n         * @name params\n         * @instance\n         * @type {*|undefined}\n         * @memberof module:workbox-strategies.StrategyHandler\n         */\n        if (process.env.NODE_ENV !== 'production') {\n            assert.isInstance(options.event, ExtendableEvent, {\n                moduleName: 'workbox-strategies',\n                className: 'StrategyHandler',\n                funcName: 'constructor',\n                paramName: 'options.event',\n            });\n        }\n        Object.assign(this, options);\n        this.event = options.event;\n        this._strategy = strategy;\n        this._handlerDeferred = new Deferred();\n        this._extendLifetimePromises = [];\n        // Copy the plugins list (since it's mutable on the strategy),\n        // so any mutations don't affect this handler instance.\n        this._plugins = [...strategy.plugins];\n        this._pluginStateMap = new Map();\n        for (const plugin of this._plugins) {\n            this._pluginStateMap.set(plugin, {});\n        }\n        this.event.waitUntil(this._handlerDeferred.promise);\n    }\n    /**\n     * Fetches a given request (and invokes any applicable plugin callback\n     * methods) using the `fetchOptions` and `plugins` defined on the strategy\n     * object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - `requestWillFetch()`\n     * - `fetchDidSucceed()`\n     * - `fetchDidFail()`\n     *\n     * @param {Request|string} input The URL or request to fetch.\n     * @return {Promise<Response>}\n     */\n    fetch(input) {\n        return this.waitUntil((async () => {\n            const { event } = this;\n            let request = toRequest(input);\n            if (request.mode === 'navigate' &&\n                event instanceof FetchEvent &&\n                event.preloadResponse) {\n                const possiblePreloadResponse = await event.preloadResponse;\n                if (possiblePreloadResponse) {\n                    if (process.env.NODE_ENV !== 'production') {\n                        logger.log(`Using a preloaded navigation response for ` +\n                            `'${getFriendlyURL(request.url)}'`);\n                    }\n                    return possiblePreloadResponse;\n                }\n            }\n            // If there is a fetchDidFail plugin, we need to save a clone of the\n            // original request before it's either modified by a requestWillFetch\n            // plugin or before the original request's body is consumed via fetch().\n            const originalRequest = this.hasCallback('fetchDidFail') ?\n                request.clone() : null;\n            try {\n                for (const cb of this.iterateCallbacks('requestWillFetch')) {\n                    request = await cb({ request: request.clone(), event });\n                }\n            }\n            catch (err) {\n                throw new WorkboxError('plugin-error-request-will-fetch', {\n                    thrownError: err,\n                });\n            }\n            // The request can be altered by plugins with `requestWillFetch` making\n            // the original request (most likely from a `fetch` event) different\n            // from the Request we make. Pass both to `fetchDidFail` to aid debugging.\n            const pluginFilteredRequest = request.clone();\n            try {\n                let fetchResponse;\n                // See https://github.com/GoogleChrome/workbox/issues/1796\n                fetchResponse = await fetch(request, request.mode === 'navigate' ?\n                    undefined : this._strategy.fetchOptions);\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.debug(`Network request for ` +\n                        `'${getFriendlyURL(request.url)}' returned a response with ` +\n                        `status '${fetchResponse.status}'.`);\n                }\n                for (const callback of this.iterateCallbacks('fetchDidSucceed')) {\n                    fetchResponse = await callback({\n                        event,\n                        request: pluginFilteredRequest,\n                        response: fetchResponse,\n                    });\n                }\n                return fetchResponse;\n            }\n            catch (error) {\n                if (process.env.NODE_ENV !== 'production') {\n                    logger.error(`Network request for ` +\n                        `'${getFriendlyURL(request.url)}' threw an error.`, error);\n                }\n                // `originalRequest` will only exist if a `fetchDidFail` callback\n                // is being used (see above).\n                if (originalRequest) {\n                    await this.runCallbacks('fetchDidFail', {\n                        error,\n                        event,\n                        originalRequest: originalRequest.clone(),\n                        request: pluginFilteredRequest.clone(),\n                    });\n                }\n                throw error;\n            }\n        })());\n    }\n    /**\n     * Calls `this.fetch()` and (in the background) runs `this.cachePut()` on\n     * the response generated by `this.fetch()`.\n     *\n     * The call to `this.cachePut()` automatically invokes `this.waitUntil()`,\n     * so you do not have to manually call `waitUntil()` on the event.\n     *\n     * @param {Request|string} input The request or URL to fetch and cache.\n     * @return {Promise<Response>}\n     */\n    async fetchAndCachePut(input) {\n        const response = await this.fetch(input);\n        const responseClone = response.clone();\n        this.waitUntil(this.cachePut(input, responseClone));\n        return response;\n    }\n    /**\n     * Matches a request from the cache (and invokes any applicable plugin\n     * callback methods) using the `cacheName`, `matchOptions`, and `plugins`\n     * defined on the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cachedResponseWillByUsed()\n     *\n     * @param {Request|string} key The Request or URL to use as the cache key.\n     * @return {Promise<Response|undefined>} A matching response, if found.\n     */\n    cacheMatch(key) {\n        return this.waitUntil((async () => {\n            const request = toRequest(key);\n            let cachedResponse;\n            const { cacheName, matchOptions } = this._strategy;\n            const effectiveRequest = await this.getCacheKey(request, 'read');\n            const multiMatchOptions = { ...matchOptions, ...{ cacheName } };\n            cachedResponse = await caches.match(effectiveRequest, multiMatchOptions);\n            if (process.env.NODE_ENV !== 'production') {\n                if (cachedResponse) {\n                    logger.debug(`Found a cached response in '${cacheName}'.`);\n                }\n                else {\n                    logger.debug(`No cached response found in '${cacheName}'.`);\n                }\n            }\n            for (const callback of this.iterateCallbacks('cachedResponseWillBeUsed')) {\n                cachedResponse = (await callback({\n                    cacheName,\n                    matchOptions,\n                    cachedResponse,\n                    request: effectiveRequest,\n                    event: this.event,\n                })) || undefined;\n            }\n            return cachedResponse;\n        })());\n    }\n    /**\n     * Puts a request/response pair in the cache (and invokes any applicable\n     * plugin callback methods) using the `cacheName` and `plugins` defined on\n     * the strategy object.\n     *\n     * The following plugin lifecycle methods are invoked when using this method:\n     * - cacheKeyWillByUsed()\n     * - cacheWillUpdate()\n     * - cacheDidUpdate()\n     *\n     * @param {Request|string} key The request or URL to use as the cache key.\n     * @param {Promise<void>} response The response to cache.\n     */\n    async cachePut(key, response) {\n        const request = toRequest(key);\n        // Run in the next task to avoid blocking other cache reads.\n        // https://github.com/w3c/ServiceWorker/issues/1397\n        await timeout(0);\n        const effectiveRequest = await this.getCacheKey(request, 'write');\n        if (process.env.NODE_ENV !== 'production') {\n            if (effectiveRequest.method && effectiveRequest.method !== 'GET') {\n                throw new WorkboxError('attempt-to-cache-non-get-request', {\n                    url: getFriendlyURL(effectiveRequest.url),\n                    method: effectiveRequest.method,\n                });\n            }\n        }\n        if (!response) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.error(`Cannot cache non-existent response for ` +\n                    `'${getFriendlyURL(effectiveRequest.url)}'.`);\n            }\n            throw new WorkboxError('cache-put-with-no-response', {\n                url: getFriendlyURL(effectiveRequest.url),\n            });\n        }\n        const responseToCache = await this._ensureResponseSafeToCache(response);\n        if (!responseToCache) {\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Response '${getFriendlyURL(effectiveRequest.url)}' ` +\n                    `will not be cached.`, responseToCache);\n            }\n            return;\n        }\n        const { cacheName, matchOptions } = this._strategy;\n        const cache = await self.caches.open(cacheName);\n        const hasCacheUpdateCallback = this.hasCallback('cacheDidUpdate');\n        const oldResponse = hasCacheUpdateCallback ? await cacheMatchIgnoreParams(\n        // TODO(philipwalton): the `__WB_REVISION__` param is a precaching\n        // feature. Consider into ways to only add this behavior if using\n        // precaching.\n        cache, effectiveRequest.clone(), ['__WB_REVISION__'], matchOptions) :\n            null;\n        if (process.env.NODE_ENV !== 'production') {\n            logger.debug(`Updating the '${cacheName}' cache with a new Response ` +\n                `for ${getFriendlyURL(effectiveRequest.url)}.`);\n        }\n        try {\n            await cache.put(effectiveRequest, hasCacheUpdateCallback ?\n                responseToCache.clone() : responseToCache);\n        }\n        catch (error) {\n            // See https://developer.mozilla.org/en-US/docs/Web/API/DOMException#exception-QuotaExceededError\n            if (error.name === 'QuotaExceededError') {\n                await executeQuotaErrorCallbacks();\n            }\n            throw error;\n        }\n        for (const callback of this.iterateCallbacks('cacheDidUpdate')) {\n            await callback({\n                cacheName,\n                oldResponse,\n                newResponse: responseToCache.clone(),\n                request: effectiveRequest,\n                event: this.event,\n            });\n        }\n    }\n    /**\n     * Checks the list of plugins for the `cacheKeyWillBeUsed` callback, and\n     * executes any of those callbacks found in sequence. The final `Request`\n     * object returned by the last plugin is treated as the cache key for cache\n     * reads and/or writes. If no `cacheKeyWillBeUsed` plugin callbacks have\n     * been registered, the passed request is returned unmodified\n     *\n     * @param {Request} request\n     * @param {string} mode\n     * @return {Promise<Request>}\n     */\n    async getCacheKey(request, mode) {\n        if (!this._cacheKeys[mode]) {\n            let effectiveRequest = request;\n            for (const callback of this.iterateCallbacks('cacheKeyWillBeUsed')) {\n                effectiveRequest = toRequest(await callback({\n                    mode,\n                    request: effectiveRequest,\n                    event: this.event,\n                    params: this.params,\n                }));\n            }\n            this._cacheKeys[mode] = effectiveRequest;\n        }\n        return this._cacheKeys[mode];\n    }\n    /**\n     * Returns true if the strategy has at least one plugin with the given\n     * callback.\n     *\n     * @param {string} name The name of the callback to check for.\n     * @return {boolean}\n     */\n    hasCallback(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (name in plugin) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Runs all plugin callbacks matching the given name, in order, passing the\n     * given param object (merged ith the current plugin state) as the only\n     * argument.\n     *\n     * Note: since this method runs all plugins, it's not suitable for cases\n     * where the return value of a callback needs to be applied prior to calling\n     * the next callback. See\n     * [`iterateCallbacks()`]{@link module:workbox-strategies.StrategyHandler#iterateCallbacks}\n     * below for how to handle that case.\n     *\n     * @param {string} name The name of the callback to run within each plugin.\n     * @param {Object} param The object to pass as the first (and only) param\n     *     when executing each callback. This object will be merged with the\n     *     current plugin state prior to callback execution.\n     */\n    async runCallbacks(name, param) {\n        for (const callback of this.iterateCallbacks(name)) {\n            // TODO(philipwalton): not sure why `any` is needed. It seems like\n            // this should work with `as WorkboxPluginCallbackParam[C]`.\n            await callback(param);\n        }\n    }\n    /**\n     * Accepts a callback and returns an iterable of matching plugin callbacks,\n     * where each callback is wrapped with the current handler state (i.e. when\n     * you call each callback, whatever object parameter you pass it will\n     * be merged with the plugin's current state).\n     *\n     * @param {string} name The name fo the callback to run\n     * @return {Array<Function>}\n     */\n    *iterateCallbacks(name) {\n        for (const plugin of this._strategy.plugins) {\n            if (typeof plugin[name] === 'function') {\n                const state = this._pluginStateMap.get(plugin);\n                const statefulCallback = (param) => {\n                    const statefulParam = { ...param, state };\n                    // TODO(philipwalton): not sure why `any` is needed. It seems like\n                    // this should work with `as WorkboxPluginCallbackParam[C]`.\n                    return plugin[name](statefulParam);\n                };\n                yield statefulCallback;\n            }\n        }\n    }\n    /**\n     * Adds a promise to the\n     * [extend lifetime promises]{@link https://w3c.github.io/ServiceWorker/#extendableevent-extend-lifetime-promises}\n     * of the event event associated with the request being handled (usually a\n     * `FetchEvent`).\n     *\n     * Note: you can await\n     * [`doneWaiting()`]{@link module:workbox-strategies.StrategyHandler~doneWaiting}\n     * to know when all added promises have settled.\n     *\n     * @param {Promise} promise A promise to add to the extend lifetime promises\n     *     of the event that triggered the request.\n     */\n    waitUntil(promise) {\n        this._extendLifetimePromises.push(promise);\n        return promise;\n    }\n    /**\n     * Returns a promise that resolves once all promises passed to\n     * [`waitUntil()`]{@link module:workbox-strategies.StrategyHandler~waitUntil}\n     * have settled.\n     *\n     * Note: any work done after `doneWaiting()` settles should be manually\n     * passed to an event's `waitUntil()` method (not this handler's\n     * `waitUntil()` method), otherwise the service worker thread my be killed\n     * prior to your work completing.\n     */\n    async doneWaiting() {\n        let promise;\n        while (promise = this._extendLifetimePromises.shift()) {\n            await promise;\n        }\n    }\n    /**\n     * Stops running the strategy and immediately resolves any pending\n     * `waitUntil()` promises.\n     */\n    destroy() {\n        this._handlerDeferred.resolve();\n    }\n    /**\n     * This method will call cacheWillUpdate on the available plugins (or use\n     * status === 200) to determine if the Response is safe and valid to cache.\n     *\n     * @param {Request} options.request\n     * @param {Response} options.response\n     * @return {Promise<Response|undefined>}\n     *\n     * @private\n     */\n    async _ensureResponseSafeToCache(response) {\n        let responseToCache = response;\n        let pluginsUsed = false;\n        for (const callback of this.iterateCallbacks('cacheWillUpdate')) {\n            responseToCache = (await callback({\n                request: this.request,\n                response: responseToCache,\n                event: this.event,\n            })) || undefined;\n            pluginsUsed = true;\n            if (!responseToCache) {\n                break;\n            }\n        }\n        if (!pluginsUsed) {\n            if (responseToCache && responseToCache.status !== 200) {\n                responseToCache = undefined;\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                if (responseToCache) {\n                    if (responseToCache.status !== 200) {\n                        if (responseToCache.status === 0) {\n                            logger.warn(`The response for '${this.request.url}' ` +\n                                `is an opaque response. The caching strategy that you're ` +\n                                `using will not cache opaque responses by default.`);\n                        }\n                        else {\n                            logger.debug(`The response for '${this.request.url}' ` +\n                                `returned a status code of '${response.status}' and won't ` +\n                                `be cached as a result.`);\n                        }\n                    }\n                }\n            }\n        }\n        return responseToCache;\n    }\n}\nexport { StrategyHandler };\n"]},"metadata":{},"sourceType":"module"}